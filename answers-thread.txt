为什么使用 2 个线程时会有缺失的键，而使用 1 个线程时没有？

因为两个线程可能同时调用 put() 并进入 insert() 函数操作同一个哈希桶。insert() 函数会创建一个新条目并将其添加到链表头部。如果两个线程同时这样做，可能会导致一个线程的添加结果被另一个覆盖，或者链表状态不一致，从而导致键丢失。

一个导致键丢失的事件序列示例：
1. 线程 T1 调用 put(key1, value1)，计算哈希 i，进入 insert()，创建新条目 e1 [key1, value1]。
2. 线程 T2 调用 put(key2, value2)，计算哈希 *也恰好是 i*，进入 insert()，创建新条目 e2 [key2, value2]。
3. T2 执行 e2->next = *p; (假设此时 *p 是旧的链表头)。
4. T1 执行 e1->next = *p; (此时 *p 可能仍然是旧的链表头，或者如果 T2 的写操作已经生效，则可能是 e2)。
5. T1 执行 *p = e1; 将 e1 设为新链表头。
6. T2 执行 *p = e2; 将 e2 设为新链表头，覆盖了 T1 的写操作 *p = e1;。结果，e1 从链表中丢失（除非 e1->next 指向了 e2，但这取决于执行的时序，通常是不确定的，常常导致丢失）。
最终，key1 对应的条目 e1 没有成功插入链表，因此后续的 get(key1) 将找不到它，报告为缺失。
